# 1. 문자열 표현
> (const&와 같이) 임의의 타입 인수를 취한 뒤, std::stringstream에 집어넣어 결과 문자열을 반환해 문자열을 생성하는 제네릭 함수 to_string을 작성하라

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-1.cpp)
# 2. 튜플의 문자열 표현
> 임의 개수의 인수를 문자열의 튜플로 나타내는 가변 템플릿 함수를 작성하라. 즉, to_tuple_string(x, y, z)를 호출하면 각 요소를 문자열 스트림에 출력해 (x, y, z) 형태의 문자열을 반환한다.
> 힌트 : 서로 다른 인수 개수를 갖도록 오버로드한 헬퍼 함수 to_tuple_string_aux를 사용하라.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-2.cpp)
# 3. 제네릭 스택
> 여러 값 타입을 받는 제네릭 스택을 구현하라. 스택의 최대 크기는 클래스에 정의되어 있다(내장 되어 있다). 다음 함수들을 제공하라

- 생성자
- (필요한 경우) 소멸자
- top : 마지막 요소를 보여준다.
- pop : (반환하지 않고) 마지막 요소를 지운다.
- push : 새로운 요소를 삽입한다.
- clear : 모든 요소를 지운다.
- size : 요소의 개수를 보여준다.
- full : 스택이 꽉 찼는지 확인한다.
- empty : 스택이 비었는지 확인한다.
스택 오버플로나 스택 언더플로가 발생하며 예외를 던져야 한다.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-3.cpp)
# 4. 벡터의 반복자
> vector 클래스의 begin 반복자와 end 반복자를 반환하는 begin() 메서드와 end() 메서드를 추가하라. 또한, 클래스에 iterator 및 conster_iterator 타입을 추가하라. 포인터는 임의 접근 반복자 개념의 모델이라는 점을 유의하라.
> 벡터의 항목들을 정렬하는 STL 함수 sort를 사용해 여러분이 작성한 반복자가 정상적으로 동작하는지 확인하라.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-4.cpp)
# 5. 홀수 반복자
> odd_iterator라는 이름의 홀수 번호를 위한 반복자 클래스를 작성하라. 클래스는 ForwardIterator 컨셉을 구현해야 한다.
> 즉, 다음 멤버들을 명백한 의미로 제공해야 한다.

- 디폴트 생성자와 복사 생성자
- operator++, 전위 증가 및 후위 증가로 다음 홀수 번호의 요소에 접근한다.
- operator*, 역참조해 (홀수) int를 반환한다.
- operator\=\=와 operator!=
- operater=

또한, 클래스에는 int 값을 취하는 생성자가 있어야 한다. 이 값은 (반복자가 증가하지 않는 한) 역참조 연산자에서 반환될 것이다. 이 생성자는 값이 짝수면 예외를 던져야 한다. 마찬가지로 디폴트 생성자는 내부 값을 1로 초기화해 합법적인 상태를 제공해야 한다.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-5.cpp)
# 6. 홀수 범위
> 홀수 번호의 범위를 위한 클래스를 작성하라. 멤버 함수 또는 자유 함수 begin과 end는 5번 문제에 정의된 odd_iterator를 반환해야 한다.
> 다음 코드는 홀수 \[7,9, …, 25\]를 출력해야 한다

``` cpp
for (int i: odd_range(7,27))
	std::cout << i << "\n";
```
[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-6.cpp)

# 7. bool 타입 스택
> 3번 문제에서 구현했던 스택을 bool 타입에 대해 특수화하라. 8개의 bool 변수 타입으로 unsigned char를 사용하라.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-7.cpp)
# 8. 임의의 크기를 갖는 스택
> 3번 문제에서 (그리고 선택적으로 7번 문제에서) 구현했던 스택을 사용자가 정의한 크기를 받을 수 있도록 수정하라. 크기는 두 번째 템플릿 인수로 전달한다. 기본값은 4096으로 한다.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-8.cpp)
# 9. 타입이 아닌 템플릿 인수 추론하기
> 우리는 함수 호출에서 템플릿 인자의 타입을 추론할 수 있음을 봤다. 타입이 아닌 템플릿 인수는 대부분의 경우 명시적으로 선언하지만, 인수 타입의 일부일 때도 추론할 수 있다. 그 예로 임의의 타입과 크기의 C 배열을 레퍼런스로 받고 그 배열의 크기를 반환하는 array_size 함수를 작성하라. 오직 타입에만 관심이 있으므로 실제 함수 인수는 생략할 수 있다. 기억하는가? 우리는 이 연습문제를 살펴봤었다. 또한 이 연습문제에서 가장 까다로운 부분을 밝혀냈다.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-9.cpp)
# 10. 사다리꼴 공식
> 함수의 적분을 계산하는 간단한 방법은 사다리꼴 공식을 사용하는 방법이다. 구간 \[a,b\]에서 함수f를 적분한다고 가정하자. 우리는 전체 구간을 동일한 길이 h = (b-a)/n를 갖는 nrodml 작은 구간 \[x<sub>i</sub>,x<sub>i+1</sub>\]으로 나눈 뒤 각 구간마다 선형 함수를 통해 f를 근사한다. 적분은 해당 함수를 적분한 값의 합으로 근사한다. 이러한 과정은 다음 공식을 유도한다.
$$I = \frac{h}{2}f(a)+\frac{h}{2}f(b)+h\sum_{j=1}^{n-1}f(a+jh)$$

> 이번 연습문제에서는, 펑터 인수를 사용해 사다리꼴 공식을 계산하는 함수를 개발한다. 비교를 위해 상속을 사용한 버전과 제네릭 프로그래밍을 사용한 버전을 구현하라. 테스트 케이스로, 다음을 적분해 보자.
- x∈\[0,4\]일 때 f=exp(3x), 다음 인수를 사용해 trapezoid를 시도해 보라.
```cpp
double exp3f(double x) {
	return std::exp(3.0 * x);
}
struct exp3t {
	double operator() (double x) const {
		return std::exp(3.0 * x);
	}
};
```
- x∈\[0,4\]일 때 x<1이면 f=sin(x), x≥1이면 f=cos(x)
- trapezoid(std::sin, 0.0, 2.0);을 호출할 수 있을까?
> 두 번째 연습문제로, 유한 차분을 계산하는 펑터를 개발하라. 개발한 다음, 유한 차분을 적분해 함숫값을 다시 얻을 수 있는지 확인하라.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-10.cpp)
# 11. 펑터
> 2 cos x + x<sup>2</sup>를 위한 펑터를 작성하고 펑터를 사용해 1차 미분과 2차 미분을 계산하라.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-11.cpp)
# 12. 람다 표현식
> 11번 문제에 있는 것과 같은 미분을 계산하되, 이번에는 람다 표현식으로 계산하라.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-12.cpp)
# 13. make_unique 구현하기
> 여러분만의 make_unique를 구현하라. 매개변수 팩을 new로 전달하려면 std::forward를 사용하라.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter3/Chapter3-13.cpp)