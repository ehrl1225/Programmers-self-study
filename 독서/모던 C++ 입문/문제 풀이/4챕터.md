# 1. 크기를 기준으로 정렬하기
> double 타입의 vector를 만들고 -9.3, -7.4, -3.8, -0.4, 1.3, 3.9, 5.4, 8.2로 초기화하라. 초기화 리스트를 사용할 수 있다. 다음을 사용해 크기를 기준으로 정렬하는 코드를 작성하라.
- 펑터
- 비교를 구현하는 람다 표현식
[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter4/Chapter4-1.cpp)

# 2. STL 컨테이너
> 전화번호를 저장하는 std::map을 만든다. 즉, string에서 unsigned long으로 매핑한다. 맵에 최소 4개의 항목을 채운다. 존재하는 이름과 존재하지 않는 이름을 검색하라. 또한, 존재하는 전화번호와 존재하지 않는 전화번호를 검색하라.

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter4/Chapter4-2.cpp)

# 3. 복소수
망델브로 집합과 유사한 쥘리아 집합의 시각화를 구현하라. 두 집합의 단순한 차이점으로는 사각형 함수에 추가된 상수가 픽셀 위치와 독립적이라는 점이다. 기본적으로 상수 k를 도입하고 iterate를 조금 수정해야한다.
- 파투 먼지라고도 하는 복잡한 칸토르 먼지인 k= = -0.6 + 0.6i로 시작하라
- k에 0.353 + 0.288i처럼 다른 값을 사용해 보라
- 소프트웨어 설계 과제는 최소한의 코드 중복성으로 망델브로 집합과 쥘리아 집합의 코드를 구현하는 것이다.
- 어려운 과제: 두 프랙탈을 대화형 방식으로 결합할 수 있다. 이를 위해 두 개의 위도를 제공해야 한다. 첫 번째는 이전과 마찬가지로 망델브로 집합을 그린다. 또한, 마우스 커서 아래의 복소수 값이 두 번째 윈도에서 설정된 쥘리아 집합의 k로 사용하도록 마우스 입력을 활성화할 수 있다.
- 보다 어려운 과제: 쥘리아 집합의 계산이 너무 느리다면 CUDA나 OpenGL에서 스레드 병렬 처리 또는 GPU 가속화를 사용할 수 있다.

제가 보기엔 징그러워 보여서 가려뒀습니다.
> [!note]- 이미지 보기
> ![[1.png]]
> ![[2.png]]

[깃허브 링크](https://github.com/ehrl1225/Modern_CPP_study/blob/main/Chapter4/Chapter4-3.cpp)


