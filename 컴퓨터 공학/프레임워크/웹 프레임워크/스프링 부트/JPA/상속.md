
# 1. @MappedSuperclass

## 목적 
엔티티들이 공통으로 가지는 매핑 정보(필드)를 정의하기 위해 사용됩니다. 
(e.g., id, createdAt, updatedAt 등)

##   특징:
   * 테이블 없음: @MappedSuperclass가 붙은 클래스는 데이터베이스 테이블과 매핑되지 않습니다.
   * 엔티티 아님: 이 클래스는 @Entity가 아니므로, JPA에서 직접 조회(em.find())하거나 JPQL 쿼리의 대상이 될 수 없습니다.
   * 상속 전용: 오직 자식 클래스에게 매핑 정보(필드)를 물려주는 역할만 합니다. 자식 클래스의 테이블에 부모 클래스의 필드들이 컬럼으로 추가됩니다.
   * 관계 설정 불가: 다른 엔티티와 @ManyToOne, @OneToMany 같은 관계를 맺을 수 없습니다.

## 예시 코드:

```kotlin
1 @MappedSuperclass // 이 클래스는 테이블과 매핑되지 않습니다.
2 public abstract class BaseEntity {
3
4     @Id @GeneratedValue
5     private Long id;
6
7     private LocalDateTime createdAt;
8     private LocalDateTime updatedAt;
9
10     // Getters and Setters...
11 }
12
13 @Entity // Member 테이블이 생성됩니다.
14 public class Member extends BaseEntity { // BaseEntity의 필드들을 물려받습니다.
15     private String name;
16     // id, createdAt, updatedAt 필드를 포함하여 테이블이 생성됩니다.
17     // (id, createdAt, updatedAt, name)
18 }
19
20 @Entity // Product 테이블이 생성됩니다.
21 public class Product extends BaseEntity { // BaseEntity의 필드들을 물려받습니다.
22     private int price;
23     // id, createdAt, updatedAt 필드를 포함하여 테이블이 생성됩니다.
24     // (id, createdAt, updatedAt, price)
25 }
```

  DB 스키마 결과: Member 테이블과 Product 테이블이 각각 생성되고, 두 테이블 모두 id, createdAt, updatedAt 컬럼을 가집니다. BaseEntity 테이블은 생성되지 않습니다.

# 2. 상속 관계 매핑 (@Inheritance)

## 목적 
객체 지향의 상속 관계를 데이터베이스에서 구현하기 위해 사용됩니다. 명확한 "IS-A" 관계를 모델링합니다. (e.g., Book IS A Item)

## 특징
   * 테이블 매핑: 부모 클래스와 자식 클래스 모두 데이터베이스 테이블과 매핑됩니다. (전략에 따라 방식이 다름)
   * 엔티티임: 부모 클래스도 @Entity이므로, JPA에서 직접 조회하거나 쿼리 대상이 될 수 있습니다.
   * 다형성 쿼리(Polymorphic Query) 가능: 부모 클래스로 조회하면 모든 자식 클래스의 데이터까지 함께 조회할 수 있습니다. (e.g., SELECT i FROM Item i)
   * 관계 설정 가능: 다른 엔티티와 관계를 맺을 수 있습니다.

## 주요 전략 
(`@Inheritance(strategy = ...)`)

   1. `JOINED` (조인 전략): 가장 정석적인 방법.
       * 부모, 자식 테이블이 각각 생성됩니다.
       * 자식 테이블은 부모 테이블의 ID를 기본 키(PK)이자 외래 키(FK)로 가집니다.
       * 장점: 데이터 정규화가 잘 되어 있고, 저장 공간이 효율적입니다.
       * 단점: 조회 시 조인이 발생하여 성능 저하가 있을 수 있습니다.

   2. `SINGLE_TABLE` (단일 테이블 전략): 기본 전략.
       * 하나의 테이블에 모든 부모와 자식의 컬럼을 포함시킵니다.
       * @DiscriminatorColumn을 두어 어떤 자식 타입인지 구분합니다. (DTYPE)
       * 장점: 조인이 필요 없어 조회 성능이 가장 빠릅니다.
       * 단점: 자식 타입이 많아지면 테이블이 너무 커지고, 특정 자식만 사용하는 컬럼들은 null 값으로 채워져 공간이 낭비될 수 있습니다.

   3. `TABLE_PER_CLASS` (클래스별 테이블 전략)
       * 자식 클래스마다 독립적인 테이블을 만듭니다. (부모 필드 포함)
       * 장점: 자식 클래스만 조회할 때 빠릅니다.
       * 단점: 다형성 쿼리 시 여러 테이블을 UNION 해야 하므로 성능이 느립니다. JPA에서 추천하지 않는 전략입니다.

  예시 코드 (단일 테이블 전략):
  ```kotlin
1 @Entity
2 @Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 단일 테이블 전략
3 @DiscriminatorColumn(name = "DTYPE") // 타입을 구분할 컬럼
4 public abstract class Item {
5
6     @Id @GeneratedValue
7     private Long id;
8
9     private String name;
10     private int price;
11     // Getters and Setters...
12 }
13
14 @Entity
15 @DiscriminatorValue("B") // DTYPE에 'B'로 저장
16 public class Book extends Item {
17     private String author;
18 }
19
20 @Entity
21 @DiscriminatorValue("A") // DTYPE에 'A'로 저장
22 public class Album extends Item {
23     private String artist;
24 }
  
  ```
  DB 스키마 결과: Item 테이블 하나만 생성되고, 모든 컬럼(DTYPE, id, name, price, author, artist)을 가집니다. Book 데이터는 artist 컬럼이 null이고, Album 데이터는
  author 컬럼이 null이 됩니다.
  