# TDD
Test-Driven Development
테스트 코드를 먼저 만들고, 실제 프로덕션 코드를 나중에 만드는 개발 방법을 말한다.

# TDD 사이클
1. 실패하는 테스트를 구현한다.
2. 테스트가 성공하도록 프로덕션 코드를 구현한다.
3. 프로덕션 코드와 테스트 코드를 리팩토링한다.

# 장점
변화에 대한 두려움을 줄여준다. (리팩토링이 편하다.)
디버깅 시간을 줄여준다.
동작하는 문서 역할을 한다.

1. TDD를 하면 자연스레 테스트 커버리지가 높아진다.
2. 오버엔지니어링 금지
3. 설계에 대한 피드백이 빠르다.

# 특징
높은 응집을 유도하지 않음
단일 책임 원칙과 인터페이스 분리 원칙 위배에 어떤 신호도 주지 않는다.
인터페이스 일관성을 도출하지 않는다.
리팩토링 단계는 좋은 구조를 안내하거나 좋은 구조를 갖도록 강제하지 않는다.


# TDD 실패 이유
코드가 이루고자 하는 가치나 기능을 테스트하기보다 그 기능을 어떻게 구현하고 있는지를 테스트한다.
테스트 케이스들이 구현체와 결합도가 높아진다.
구현체들을 리팩토링하면 결합되어있는 테스트 케이스들이 모두 깨져버린다.

따라서 우리는 구현체가 아닌 인터페이스를 테스트해야한다.

# 테스트 범위
인수, 부하, 기능, 통합, 단위로 나눠지고 왼쪽이 가장 큰 개념 오른쪽이 가장 작은 개념이고 왼쪽이 오른쪽을 포함함

## 통합 테스트
여러 작업 단위가 연계된 워크플로우를 테스트하기 위한 수단
## 기능 테스트
공개된 API의 가장 바깥쪽에 해당하는 코드 검사
## 부하 테스트
주어진 단위 시간 동안 어플리케이션이 얼마나 많은 요청을 처리할 수 있는지 검사
## 인수 테스트
고객 또는 대리인이 정의되어진 모든 목적에 부합되는지 확인해보고자 하는 검사

# 단위 테스트
가장 작은 단위의 테스트
일반적으로 메서드 레벨이다.
검증이 필요한 코드에 대해 테스트 케이스를 작성하는 절차 또는 프로세스다.
테스트 코드가 목적 코드의 완전성을 입증해주기 때문에, 테스트 코드 그 자체만으로 주요한 가치가 있다.

## 단위 테스트 목적
- 문제 발견
- 쉬운 변경
- 품질 향상
- 코드의 문서화


## 좋은 단위 테스트
F.I.R.S.T 법칙
Fast (빠르게)
Independent(독립적으로)
Repeatable(반복 가능하게)
Self-Validating(자가 검증하는)
Timely(적시에)
