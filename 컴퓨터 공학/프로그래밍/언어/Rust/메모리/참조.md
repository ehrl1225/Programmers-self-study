# 불변 참조자
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

이렇게 참조를 넘겨주고 함수가 끝난 후에도 소유권을 유지할 수 있다.

# 가변 참조자
빌려서 수정을 해야 하는 경우
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
`mut`을 붙어야 한다.

특정한 스코프 내에 특정한 데이터 조각에 대한 가변 참조자는 하나만 만들 수 있다.
그리고 불변 참조자가 있는 상태에서 가변 참조자를 만들면 안된다.


# 댕글링 참조자
```rust
fn dangle() -> &String { // dangle은 String의 참조자를 반환합니다

    let s = String::from("hello"); // s는 새로운 String입니다

    &s // 우리는 String s의 참조자를 반환합니다.
} // 여기서 s는 스코프를 벗어나고 버려집니다. 이것의 메모리는 사라집니다.
  // 위험하군요!
```
이런식으로 함수 내에서 객체를 만들고 객체에 대한 참조를 반환하면
함수가 종료되면 참조에 의미가 없어지므로 문제가 발생한다.
따라서

```rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```
이렇게  객체를 반환해야한다.
