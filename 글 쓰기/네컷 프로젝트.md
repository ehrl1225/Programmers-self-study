# 프로젝트 시작하게 된 이유
나는 어느 날 교회 형에게 인터넷에 있는 네컷 사진을 찍는 프로그램을 
고등학생들이 제작하는 영상을 보여주며 만들어 줄 수 있냐는 제안을 받았다.
내가 보기에는 어려운 점은 보이지 않았다.
내가 이미 가지고 있는 지식은 
OpenCV를 통해 카메라를 제어 가능하고
프린터는 아마 다른 사람이 만들어둔 라이브러리가 있을 거라 생각했고
GUI는 Qt나 Flutter로 제작이 가능했기에 문제가 없었다.
그래서 만들겠다고 했다.

# 요구 사항
카메라와 연결해야한다고 했다.
그래서 카메라와 연결하면 웹캠처럼 쓸 수 있어야 한다. 라고 설명했다.
그래서 찾아보니 웹캠처럼 사용할 수 있는 방법이 있었다.
그래서 카메라를 사용하기로 했고

크기는 4\*6인치로 이루어진 포토용지다.
프레임은 내가 제작하지 않고 제작을 해줄 것이고
여러 개의 프레임을 선택할 수 있어야한다.
여기서는 각 프레임마다 입력해야 할 사진의 왼쪽 위 좌표, 오른쪽 아래 좌표를 작성하면
사진을 편집할 수 있을거라 생각했고 이는 JSON 파일로 작성하면 된다고 생각했다.
그래서 왼쪽 위 점, 오른쪽 아래 점을 찍을 수 있으면 된다고 했다.

프로젝트를 진행하다가 요구 사항이 추가로 발생했다.
사진을 찍을 때 사진에 스탬프처럼 찍히는 것을 원했다.
이거는 생각을 해보니 편집 프로그램에서 레이어를 나누듯
프레임 레이어, 사진 레이어, 오버레이 레이어로 구성해서
하나하나 덮어쓰기 하면 된다고 생각했다.


## 서비스 흐름
6개의 사진을 찍고 4개를 선택하고 프레임을 선택하면 편집해서 프린터로 출력하면 된다.

# 구상
프로젝트를 제작할 시간은 2달정도 된다.
프로젝트를 빠르게 제작하는게 좋을 거라 생각하여
가장 익숙한 언어인 파이썬을 통해
속도와 확장성을 통해 빠르고 다양한 기능을 한번에 제작 가능하게 만들려고 했다.

처음에 생각한 방식은 카메라를 제어할 때 내가 가지고 있는 미니 컨트롤러를 통해 
키보드 조작을 하여 카메라를 찍고

파이썬으로 제작한 GUI 앱, Flask 웹 서버, Flutter를 사용한 앱을 제작하여
GUI 앱과 웹 서버는 웹 소켓으로 연결되고
웹 서버와 Flutter 앱은 Post를 통해 서로 통신하면 된다고 생각했고

GUI 앱에서 사진을 찍으면 이미지를 파일로 저장하고 
웹 서버로 사진을 다 찍었다는 신호를 보내면

사진을 Flutter 앱으로 조회가 가능해지고
사진을 선택한 후 선택한 이미지를 서버로 보내서
서버에서 웹소켓을 통해 GUI 앱에게 선택을 다 했다는 신호와
선택한 이미지를 제공 받아서
이 이미지를 바탕으로 편집을 할 생각을 했다.

근데 이 아이디어는 통과되지는 않았고
마우스로 사진을 클릭해서 선택하는 방식으로 정했다.
따라서 PyQt6를 통해 GUI를 구현하고
프린터기와는 win32print, win32ui를 통해 연결해서 출력하고
사진 편집으로는 OpenCV-python 모듈을 사용해서 편집하려고 했다.

일단 요구 사항으로는
시작 화면,
몇 장을 출력 할지 정하는 화면,
사진을 찍는 화면,
찍은 사진 중 4장 고르는 화면,
사진을 어느 프레임에 편집할지 고르는 화면,
사진을 프린터로 출력하면서 표시될 화면,
출력 완료되었으며 처음으로 돌아가게 하는 화면
을 만들면 되었다.

사진은 6장을 찍고 4장을 선택하기로 했다.

프레임이 여러 개이므로 프레임 사진과 프레임 중 
사진을 편집해야하는 위치의 왼쪽 위 좌표와 오른쪽 아래 좌표를 저장하면 되었다.
그리고 그 정보는 json파일에 저장하는 게 편할 거라고 생각했다.

그리고 화면에는 직접 그림을 제공할 건데 그림을 넣어달라고 해서 그러겠다고 했다.

그러다가 한가지 요구사항이 더 나타났다.
이미지를 주면 그 이미지를 앞에 덮어쓰게 사진을 찍는 기능을 만들 수 있냐는 것이었다.
기존에도 프레임에 사진을 덮어쓰기도 했으니까
레이어를 3개로 생각해서 덮어쓸 사진, 카메라로 찍은 사진, 프레임 그림, 이렇게 덮어쓰면 되겠다고 생각해서 하겠다고 했다.
근데 문제가 발생하는 게 기존의 방식은 6장을 찍고는 4장을 선택해서 편집을 해야하는데
앞에 사진을 넣으면 4장은 오버레이 사진을 띄우면 되는데 
나머지 2번의 사진 촬영은 어느 오버레이 사진을 띄워야 하냐는 문제가 있었다.
따라서 오버레이를 앞에 넣는 사진의 경우는 4번만 촬영하기로 했다.
그러기 위해서는 프레임을 고르는 화면이 좀 더 빨리 표시되어야 했다.
따라서 화면의 배치를 변경했다.
- 시작 화면
- 몇 장을 출력 할 지 정하는 화면
- 프레임을 고르는 화면
- 사진을 찍는 화면
- (optional) 4장을 찍는 경우 오버레이 편집된 화면을 보여주는 화면
- (optional) 6장을 찍는 경우 4장을 고르는 화면
- 사진을 프린터로 출력하면서 표시될 화면
- 출력 완료 되었으며 처음으로 돌아가게 하는 화면

6번 찍을지 4번을 찍을지는 오버레이 사진의 데이터가 존재 여부고 구분이 가능하였다.

한가지 요구 사항이 더 생겼다.
프레임 그림이 있는데 사진 영역을 침범하는 것도 추가하는 것이다.
이거는 4장만을 찍을 필요는 없고 6장을 찍으면 된다.
사진찍을 때 사진 영역을 침범하는 오버레이는 표시하지 않아도 된다.
그러면 오버레이 사진이 존재하지만 카메라에는 표시 안된다는 것인데
그래서 프레임 데이터를 저장할 때 overlay_on_cam의 값을 저장하기로 했다.
그걸 통해서 몇 장을 찍을 지 정했다.


# 구현
## GUI
GUI는 PyQt6로 작성했다.
하나의 창에 여러 개의 위젯이 번갈아 등장하는 방식으로 작성했다.
### WelcomeWidget
가장 처음에 표시될 화면이다.
처음에는 글자와 버튼을 만들어 두었고
이후에는 그림을 받아서 글자는 없애고
버튼은 투명하게 해두고 그림의 버튼 위치에 맞게 조절했다.

### SelectPeopleNumberWidget
숫자를 표시하는 버튼, 1을 빼는 버튼, 1을 더하는 버튼, 다음 페이지로 이동하는 버튼이 있다.
이미지 위에 그리는 것이라서
버튼들은 투명하게 변경했고
숫자를 표시하는 버튼은 이미지에 맞게 배경색을 맞춰뒀다.

### ImageWidget
이미지 위젯은 이미지와 관련된 화면들을 관리한다.
이 위젯이 생성이 될 때 프레임 데이터를 불러오고 프레임 위젯에 불러온 사진을 표시한다.

#### FrameChoosingWidget
프레임 그림을 표시하고 그림 밑에 버튼을 두어서 선택이 가능하고
그림을 클릭해도 선택이 가능하게 만들었고
다음 화면으로 넘어갈 수 있다.

#### ImageCaptureWidget
이 위젯은 사진을 찍기 위해 만들었다.
사진을 찍는 게 IO 작업이니 서브 스레드인 ImageCaptureWorker를 가진다.
카메라를 열고 닫는 작업이 시간이 좀 걸리는 문제가 있어서 
해당 위젯이 생성되는 순간부터 카메라를 켜둔다.
따라서 프로그램이 시작부터 끝까지 카메라는 켜져있다.
QTimer를 통해 1초마다 카운트 다운을 하며
카운트 다운이 0이되면 QSoundEffect()를 통해 찰칵하는 소리를 낸다.
그러니까 카메라에서 소리가 나진 않는다.
사진을 찍기 전에는 해시값으로 폴더를 생성하고
그 폴더에 찍은 사진을 저장한다.

##### ImageWorker
openCV를 통해 카메라를 열어서 사진을 카메라로 부터 받아서 
콜백 함수를 통해 전해보낸다.

#### ImageShowWidget
오버레이 편집을 했을 때 어떻게 보이는지 보여주는 화면이다.
다시 뒤로 돌아 갈 수 있고 
#### ImageChoosingWidget
grid layout을 만들어 3x2로 표현을 한다.
클릭하면 왼쪽 위에 몇 번째 사진인지 표시하고
그리고 선택 완료 버튼을 누르면 다음 화면이 나온다.

#### ImagePrintingWidget
이 위젯은 프린트를 하는 동안 두 개의 사진을 번갈아서 표시하면서 대기하는 화면으로 만들려고 했으나 프린트가 종료될 때까지 기다리지 않아서 해당 위젯으로 이동하는 기능을 막아뒀다.

#### ImagePrintingDoneWidget
이 위젯은 프린트가 종료되었다는 그림과 처음으로 돌아가는 버튼이 있어서
해당 버튼을 누르면 처음으로 돌아간다.

## image

### FourCutData
한 프레임의 필요한 데이터를 다 가지고 있다.
프레임 그림, 편집해야하는 사진의 위치, 오버레이 사진들, 오버레이 사진 위치
촬영시 오버레이를 표시할지도 저장한다.

### ImageCapture
카메라를 열고 닫고
카메라에서 사진을 가져오는 기능을 담당한다.

### ImageEditor
이미지 편집을 담당하는 클래스다.
비율에 맞게 크기를 조절하고
조절하고 나서 튀어나온 부분이 있으면 잘라내기도 하고
카메라로 찍은 사진을 편집하는 기능과
오버레이의 불투명한 부분만 편집하는 기능도 있고
실제 카메라를 사용할 때 위와 아래에 생기는 검은 띠를 제거하기도 한다.

### ImageUtil
ndarray를 QImage로 변경하기도 하고
ndarray를 QPixmap으로 변경하기도 하고
QImage를 ndarray로 변경하기도 하고
이미지를 저장하기도 한다.

### PhotoRect
사진의 위치와 크기를 같이 저장하기 위한 클래스다.
왼쪽 위와 오른쪽 아래 좌표를 저장하는 값이다.


## printer

### Printer
프린트를 담당하는 클래스다.
프린터를 설정할 수 있고 초기값으로는 윈도우에 기본프린터로 되어있다.
프린터 목록을 조회할 수 있고
이미지 경로와 개수를 적으면 프린트를 시작한다.

## util
### DataManager
초기에 설정해야하는 프레임 사진, json파일들을 불러와서 FourCutData를 저장하기도 하고
위젯들 중 전역으로 저장해야 하는 값을 저장한다.

# 발생한 오류
## GUI 문제
한 윈도우 창에 여러가지 위젯이 순서대로 나타났다가 사라지는 방식을 하는데
한 위젯이 화면 바깥까지 자리를 잡게 되니까
그 외 모든 위젯들의 위치가 변경되는 문제가 발생했다.
문제는 GUI는 디버깅이 어렵다는 점이었다.
그래서 원인은 모르고 억지로 맞춰서 진행하다가.
실수로 한 위젯의 크기를 엄청 크게 만들었는데 다른 위젯에 영향을 미치는 것을 확인해서
그 이후로 어느 위젯이 화면 바깥으로 나갈정도로 큰지 확인하다가 원인을 발견하고
크기를 조절해 버그를 고쳤다.


## 패키지 매니징을 하지 않아서 발생한 문제
실행시키는 노트북은 내가 가지고 있는 노트북이 아닌
교회 형의 노트북으로 돌려보려고 했는데
안타깝게도 실행시키니 코드의 위치를 찾지 못해 실행이 안되는 문제가 발생했다.

그래서 고친 방법은 main.py 파일을 프로젝트 폴더의 가장 상위로 변경했다.
그러자 어느정도 고쳐졌고

나중에 UV 모듈을 찾게 된 계기가 되었다.

## 운영체제가 다름에 따라 웹캠 프로그램 호환 문제
한번 내가 가지고 있는 맥북으로 변경해서 실행시켜보려고 했는데
카메라와 맥북과 연결해도 맥북에서 인식을 못하는 문제가 발생했다.

그래서 프로젝트는 맥북으로 실행시키지 않기로 했다.

## 얕은 복사 문제
이상하게 편집에 실패하는 문제가 발생했다.
분명 편집하기 전 크기를 조절해주는 기능을 만들었는데
크기가 맞지 않아 편집이 안된다는 것이었다.
그래서 크기를 계산하는 클래스의 값을 출력해보니 음수의 길이를 가지는 문제가 발생했는데
크기를 계산하는 클래스의 값은 프로젝트 전체 클래스에서 사용하기 위한 용도로 제작했다.
시작할 때는 한번 설정하고 변경할 생각이 없었다.
나중에는 변경된 값이 필요해 값을 변경했고 이게 그 다음 프레임에게도 영향을 미쳐서
연속적으로 크기의 값을 계산하다 보니 예상치 못한 값을 가지게 된 것이다.

그래서 깊은 복사를 하는 함수를 추가해 현재 프레임에게만 영향을 미치게 수정했다.

## 서브 스레드가 죽는 문제
PyQt에서 QThread를 통해 스레드를 분리할 수 있다.
서브스레드에서는 카메라에서 이미지를 가져오고 나서
편집을 하고 메인 스레드로 pyqtSignal을 통해 이미지를 전송하는데
pyqtSignal에서는 OpenCV에서 사용하는 Numpy 배열을 전송할 수 없다.
QImage를 전송이 가능한데 그러기 위해서는 변환 작업이 필요하다.
테스트 환경인 웹캠에서는 정상 작동했는데 
실제 사용할 카메라와 연결하니 죽어버렸다.

문제를 찾는 과정이 어려웠는데
PyQt에서는 오류가 발생해서 종료가 될 때
에러가 표현이 되지 않는다.
어디에서 문제가 발생했는지를 확인하는 과정부터 시작해야했다.
처음에는 기존과 현재 무슨 차이인지 파악을 했다.
맥북의 카메라와 현장에서 사용할 카메라의 차이만 있기 때문에
차이는 사진의 해상도 차이라고 생각했고
서브 스레드의 코드를 주석처리를 하자
기능만 사라지고 실행은 되었기에 
서브 스레드의 문제라고 파악을 했다.
그리고 서브 스레드에 너무 많은 메모리를 가지면 안된다는 것을 
이전의 버그 수정 때 발견한 기억이 있었다.
따라서 문제는 서브 스레드에 너무 많은 메모리를 가졌다고 생각했다.


그래서 해결한 방법은
서브 스레드에 callback 함수를 넣어서 OpenCV를 통해 이미지를 가져오면 QImage로 변환하지 않고
Numpy 배열 상태로 callback 함수에 매개변수로 넣고 실행시켜 메인 스레드에서 편집하게 수정했다.
그러자 실행 중 서브 스레드가 죽어서 프로그램이 종료되는 문제가 발생하지 않게 되었다.

# github
[링크](https://github.com/ehrl1225/FourCutPhoto)
